Preliminary notes on using this parser, Version 3;0;00:

This parser implements the 3rd baseline as published in _The Complete
Lojban Language_.

The parser reads from standard input and writes to standard output.
These may be redirected on the command line with the usual < and > symbols.
You can also specify the input file as a single argument. If no file is
specified, and standard input is not redirected, the parser will re-execute
itself repeatedly and will process only a single line (you can break up the
single line by using backslash-newline; see below).

Command-line options:
	-d[vLRlre*]   Debug flags (combine letters):
								v=valsi, L=cpd_lex, R=cpd_reduce, l=lex, r=reduce, e=elidable, *=all
	-t            Tree output
	-s            Simple mode (flatten single-child nodes)
	-e            Elide mode (omit insertion of elidables)
	-f            Full parse (do not collapse single-child nodes)
	-p            Prolog-style output (rule/selma'o names as functors)
	-y            YAML-like output (structured listing)
	-c            Generate cmavo list and exit
	-h, --help    Show help and exit
	--version     Show version and exit

Input is preprocessed as follows:
	Upper-case letters are changed to lower-case.
	The . character is treated as a space.
	Text enclosed in slashes is ignored.
	Newlines preceded by an \ character are ignored.
	Digits are converted to the corresponding cmavo.
	All other non-alphabetic characters (note that apostrophe is
		alphabetic) are ignored.

These rules allow the re-parsing of parsed text without error.

At the end of each parse, the parser prints the space used in bytes (broken
down into token space and string space) and the time in seconds. Times are not
printed when running interactively.

Building
--------

Use make to build the parser:

	make

This produces the binary 'parser'. For a build with debug symbols and extra warnings (default), the Makefile sets -g -O0 -Wall -Wextra.

To build with AddressSanitizer for memory debugging:

	make asan

Project structure
-----------------

- include/
	- Public headers (e.g., grammar.h, token.h, lojban.h, node.h, version.h)
- src/
	- All C sources (moved from repo root)
- docs/
	- Documentation and checklists
- tests/
	- Simple smoke tests and data
- grammar/
	- Grammar assets; `grammar/grammar.y` is generated by mkgramy (see Regenerating grammar)
- rulename.i, selmao.i
	- Generated include fragments used by src/rulename.c and src/selmao.c

Regenerating grammar and names
------------------------------

Regenerate the parser sources and name tables from a publication baseline using the `regen` target:

	make regen

What `make regen` does:

- Runs `./mkgramy $(BASELINE)` to build `grammar/grammar.y` from `grammar.$(BASELINE)` and updates `include/version.h`.
- Invokes bison (or yacc) to generate `src/grammar.c` and `include/grammar.h`.
- Runs `./mknames` to rebuild `rulename.i` from `grammar/grammar.y` and `include/grammar.h`.

Notes:

- Set `BASELINE` on the command line to switch baselines (defaults to 300):

	make regen BASELINE=233

- `mknames` reads `include/grammar.h`; the regen step no longer writes a header into the repo root, so your hand-edited root `grammar.h` (if any) will not be clobbered.
- The generated files `src/grammar.c`, `include/grammar.h`, `rulename.i`, and `grammar/grammar.y` are reproducible from the inputs in this repo. Avoid editing them by hand; changes will be overwritten by regen.

GLR mode (optional):

- To build a GLR-capable parser with Bison, use:

	make glr

  This regenerates the grammar including `gmiddle.glr.y` (which enables `%glr-parser`) and builds.
  You can also run `make regen GLR=1` to only regenerate with GLR enabled.

Grammar exports and diagrams (optional)
--------------------------------------

- Export an EBNF-like view of the generated grammar for documentation:

	make ebnf    # writes grammar/grammar.ebnf

- Generate simple railroad diagrams (requires `ebnf2railroad` on PATH):

	make diagrams  # writes docs/grammar_railroad.html (if tool is available)

Lark grammar export (experimental)
----------------------------------

- Generate a Lark-compatible grammar skeleton from the generated YACC grammar:

    	make lark       # writes grammar/grammar.lark
    	make check-lark # verifies grammar.lark loads in Lark (internal consistency)

What this is:
- A convenience export for experimentation with the Python 'lark' parser (Earley).
- It declares the nonterminals and references terminal names via `%declare` lines.

What this is NOT:
- A drop-in, fully working parser. The generated file does not define token regexes;
	you must provide a lexer that emits the declared tokens (mirroring the C lexer).

How to try with Lark:
- Install lark and run the example adapter which feeds a token stream into Lark:

		python3 examples/parse_with_lark.py --show-tree "mi klama"

Notes and caveats:
- Use Earley: the example uses `parser='earley'` and `ambiguity='explicit'` to tolerate
	the grammar's ambiguity similarly to Bison GLR.
- The toy adapter maps a tiny subset of Lojban words to declared tokens (cmavo, brivla,
	names). Extend this mapping to reflect the real classification rules.
- Treat grammar/grammar.lark as derived documentation for experiments; the C parser
	remains the source of truth.

Contributor notes
-----------------

- Workflow
	- Edit grammar sources as needed (publication baselines are `grammar.233` or `grammar.300`).
	- Regenerate artifacts: `make regen` (optionally `BASELINE=233`).
	- Build: `make` (optionally `make STRICT=1` for extra warnings).
	- Test: `make test` to run smoke tests; `make asan`/`make ubsan` are helpful for debugging.
- Where to put files
	- C sources live in `src/`; public headers in `include/`.
	- Grammar assets live in `grammar/`; `grammar/grammar.y` is generated by mkgramy.
	- Generated files: `src/grammar.c`, `include/grammar.h`, `rulename.i`, and `selmao.i`.
		Do not edit these by hand; rerun `make regen` or the appropriate generator instead.
	- Tests and sample inputs live in `tests/`.

Testing output formats
----------------------

A small smoke test runs the parser over a sample file and exercises the main output modes:

	make test

It runs the following forms and prints the first few lines:

	./parser openwm.txt         # default print
	./parser -p openwm.txt      # Prolog-style output
	./parser -t openwm.txt      # tree output
	./parser -y openwm.txt      # YAML-like output

Regression tests
----------------

Golden tests compare current outputs against committed baselines for a small input set.

	make regress          # run comparisons
	make regress-update   # refresh goldens from current parser

Usage examples
--------------

	./parser < textfile
	./parser -p textfile
	echo "mi klama" | ./parser -t

Troubleshooting
---------------

- If you see a segmentation fault when using -p (Prolog output), ensure you are running a build that includes fixes which avoid mutating literal strings (this README assumes you are).
- For crashes or unexpected behavior, try 'make asan' and re-run to get sanitizer diagnostics.
- If `make regen` fails on header generation, ensure you have one of: `bison` or `yacc`, plus `awk` and `cpp` in your PATH.
- If `mknames` complains about `include/grammar.h`, run `make regen` first (it is produced there).

Build options
-------------

- Choose C standard: default is c11; override with STD

	make STD=c17

- Opt-in stricter warnings: enable additional warnings via STRICT=1

	make clean && make STRICT=1

- Sanitizers:
  - AddressSanitizer: make asan
  - UndefinedBehaviorSanitizer: make ubsan

- Static analyzer (GCC 10+):

	make analyze

- End-to-end local CI flow (clean → regen → build → test):

	make ci

- Verbose output mapping to debug flags:
  - Default verbose: ./parser --verbose file
  - Higher verbosity: ./parser --verbose=2 -p file

Makefile knobs and targets (summary)
------------------------------------

- Knobs (variables)
	- `STD`         Choose C standard (default c11), e.g., `make STD=c17`.
	- `STRICT=1`    Enable extra warnings (`-Wpedantic -Wshadow -Wconversion -Wpointer-arith -Wformat=2`).
	- `BASELINE`    Grammar baseline for regen (default 300), e.g., `make regen BASELINE=233`.
    - `GLR=1`      Regenerate grammar using GLR middle rules (used by `make regen GLR=1`; `make glr` wraps this).
- Targets
	- `make`        Build the parser
	- `make regen`  Rebuild grammar-generated sources and names
	- `make glr`    Regenerate with GLR enabled and build
	- `make test`   Run smoke tests
	- `make regress`         Run golden regression tests
	- `make regress-update`  Refresh goldens for regression tests
	- `make asan`   Build with AddressSanitizer
	- `make ubsan`  Build with UndefinedBehaviorSanitizer
	- `make analyze` Run GCC static analyzer (when available)
	- `make ci`     End-to-end: clean → regen → build → test
    - `make ebnf`     Export EBNF-like grammar (grammar/grammar.ebnf)
    - `make diagrams` Generate simple railroad diagrams (optional tool)
	- `make lark`       Export a Lark grammar skeleton (grammar/grammar.lark)
	- `make check-lark` Validate the exported Lark grammar loads successfully
